@use 'sass:list';
@use 'sass:meta';
@use 'sass:map';
@use 'utils/functions' as f;
@use 'variables/breakpoints' as b;
@use 'variables/css-properties' as p;

@mixin mw($breakpoint: sm) {
    @if map.has-key(b.$breakpoints, $breakpoint) {
        @media (min-width: #{map.get(b.$breakpoints, $breakpoint)}px) {
            @content;
        }
    } @else {
        @warn "Breakpoint '#{$breakpoint}' not found in $breakpoints map.";
    }
}
/* @media (min-width: f.rem(map.get(b.$breakpoints, $breakpoint))) { */

@mixin rm($property, $sizes...) {
    @if not map.has-key(p.$css-properties, $property) {
        @error "Unknown CSS property `#{$property}`. "
                 + "It is not in p.$css-properties and is not a valid CSS identifier.";
    }

    $css-property: map.get(p.$css-properties, $property);

    $breakpoint-keys: ('sm', 'md', 'lg', 'xl');

    $figma-values: map.values(b.$figma-bps);
    $bp-values: map.values(b.$breakpoints);

    @for $i from 1 through list.length($sizes) {
        $size: list.nth($sizes, $i);

        @if $size != null {
            $figma-breakpoint: list.nth($figma-values, $i);
            $bp-breakpoint: list.nth($bp-values, $i);
            $lower-limit: if($i == 1, 200, list.nth($bp-values, $i - 1));

            @if $i == 1 {
                #{$css-property}: f.calc-adaptive-rm(
                    $size,
                    $figma-breakpoint,
                    $bp-breakpoint,
                    $lower-limit
                );
            } @else {
                $breakpoint-key: list.nth($breakpoint-keys, $i - 1);
                @include mw($breakpoint-key) {
                    #{$css-property}: f.calc-adaptive-rm(
                        $size,
                        $figma-breakpoint,
                        $bp-breakpoint,
                        $lower-limit
                    );
                }
            }
        }
    }
}

@mixin px($property, $sizes...) {
    @if not map.has-key(p.$css-properties, $property) {
        @error "Unknown CSS property `#{$property}`. "
                 + "It is not in p.$css-properties and is not a valid CSS identifier.";
    }

    $css-property: map.get(p.$css-properties, $property);

    $breakpoint-keys: ('sm', 'md', 'lg', 'xl');
    $figma-values: map.values(b.$figma-bps);
    $bp-values: map.values(b.$breakpoints);

    @for $i from 1 through list.length($sizes) {
        $size: list.nth($sizes, $i);
        @if $size != null {
            $figma-breakpoint: list.nth($figma-values, $i);
            $bp-breakpoint: list.nth($bp-values, $i);
            $lower-limit: if($i == 1, 200, list.nth($bp-values, $i - 1));

            @if $i == 1 {
                #{$css-property}: f.calc-adaptive-px(
                    $size,
                    $figma-breakpoint,
                    $bp-breakpoint,
                    $lower-limit
                );
            } @else {
                $breakpoint-key: list.nth($breakpoint-keys, $i - 1);
                @include mw($breakpoint-key) {
                    #{$css-property}: f.calc-adaptive-px(
                        $size,
                        $figma-breakpoint,
                        $bp-breakpoint,
                        $lower-limit
                    );
                }
            }
        }
    }
}

@function top-shadow($depth) {
    $primary-offset: list.nth(1.5 3 10 14 19, $depth) * 1px;
    $blur: list.nth(1.5 3 10 14 19, $depth) * 4px;
    $color: rgba(black, list.nth(0.12 0.16 0.19 0.25 0.3, $depth));

    @return 0 $primary-offset $blur $color;
}

@function bottom-shadow($depth) {
    $primary-offset: list.nth(1.5 3 6 10 15, $depth) * 1px;
    $blur: list.nth(1 3 3 5 6, $depth) * 4px;
    $color: rgba(black, list.nth(0.24 0.23 0.23 0.22 0.22, $depth));

    @return 0 $primary-offset $blur $color;
}

@mixin shadow($depth) {
    @if $depth < 1 {
        box-shadow: none;
    } @else if $depth > 5 {
        @warn "Invalid $depth `#{$depth}` for mixin `shadow`.";
    } @else {
        box-shadow: bottom-shadow($depth), top-shadow($depth);
    }
}

@mixin shine {
    position: relative;
    overflow: hidden;

    &::after {
        content: '';
        position: absolute;
        top: 0;
        left: -75%;
        z-index: 2;
        width: 50%;
        height: 100%;
        background: linear-gradient(
            to right,
            rgba(255, 255, 255, 0) 0%,
            rgba(255, 255, 255, 0.3) 100%
        );
        transform: skewX(-25deg);
        pointer-events: none;
    }

    &:hover::after {
        animation: shine 750ms forwards;
    }
}

@keyframes shine {
    100% {
        left: 125%;
    }
}

@mixin fxc() {
    display: flex;
    align-items: center;
    justify-content: center;
}

@mixin underline-slide() {
    position: relative;

    &::after {
        content: '';
        position: absolute;
        bottom: -0.2em;
        left: 0;
        width: 0%;
        height: 0.1em;
        flex-shrink: 0;
        background-color: currentColor;
        opacity: 1;
        transition: width 300ms;
    }

    &:hover::after,
    &:focus::after {
        width: 100%;
    }
}

@mixin size($width, $height: $width) {
    width: $width;
    height: $height;
}
